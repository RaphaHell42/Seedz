# -*- coding: utf-8 -*-
"""machine_learning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dGpIPgb3Z-goLZu1YWGknPFZ29tmQS2R
"""

# Affichage des données d'entrainement

import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

import pandas as pd
import numpy as np
import pprint
import matplotlib.pyplot as plt
import plotly.plotly as py
from plotly.graph_objs import *
from openpyxl import *
from scipy import signal
from plotly.offline import *


# Affichage de tous les tests de représentation des données
show = 0


# Chargement du jeu de données dans un dataframe

wb = load_workbook(filename = 'data_plant.xlsx', data_only=True)
ws = wb.worksheets[0]
data_rows = []
for row in ws['A1':'E1936']:
    data_cols = []
    for cell in row:
        data_cols.append(cell.value)
    data_rows.append(data_cols)
data_plant = pd.DataFrame(data_rows)
if(show == 1):
    print(data_plant)

# Test de représentation des données n°1

x = data_plant[2]
y = data_plant[4]
trace1 = Scatter(
    x = x,
    y = y
)
layout = Layout(
    showlegend=True
)
data = [trace1]
fig = Figure(data=data, layout=layout)
if(show == 1):
    plot(fig, filename='basic-line.html')

    
# Test de représentation des données n°2

data = [
    Bar(
        x=data_plant[2],
        y=data_plant[4]
    )
]
if(show == 1):
    plot(data, filename='basic-bar.html')


# Test de représentation des données n°3

trace1 = Scatter(
    x=data_plant[4],
    y=data_plant[0],
    name='Luminosité'
)
trace2 = Scatter(
    x=data_plant[4],
    y=data_plant[1],
    name='Hygrometrie',
    yaxis='y2'
)
trace3 = Scatter(
    x=data_plant[4],
    y=data_plant[2],
    name='Humidité',
    yaxis='y3'
)
trace4 = Scatter(
    x=data_plant[4],
    y=data_plant[3],
    name='Température',
    yaxis='y4'
)
data = [trace1, trace2, trace3, trace4]
layout = Layout(
    title='Representation data_plant sur plusieurs axes',
    width=800,
    xaxis=dict(
        domain=[0.3, 0.7]
    ),
    yaxis=dict(
        title='Luminosité',
        titlefont=dict(
            color='#1f77b4'
        ),
        tickfont=dict(
            color='#1f77b4'
        )
    ),
    yaxis2=dict(
        title='Hygrometrie',
        titlefont=dict(
            color='#ff7f0e'
        ),
        tickfont=dict(
            color='#ff7f0e'
        ),
        anchor='free',
        overlaying='y',
        side='left',
        position=0.15
    ),
    yaxis3=dict(
        title='Humidité',
        titlefont=dict(
            color='#d62728'
        ),
        tickfont=dict(
            color='#d62728'
        ),
        anchor='x',
        overlaying='y',
        side='right'
    ),
    yaxis4=dict(
        title='Température',
        titlefont=dict(
            color='#9467bd'
        ),
        tickfont=dict(
            color='#9467bd'
        ),
        anchor='free',
        overlaying='y',
        side='right',
        position=0.85
    )
)
fig = Figure(data=data, layout=layout)
if(show == 1):
    plot(fig, filename='Representation data_plant sur plusieurs axes.html')


# Test de représentation des données n°4

trace1 = {
  "z": [
    data_plant[0],data_plant[1],data_plant[2],data_plant[3]],
   "colorscale": [
    [0, "rgb(0,0,255)"], [0.1, "rgb(51,153,255)"], [0.2, "rgb(102,204,255)"], [0.3, "rgb(153,204,255)"], [0.4, "rgb(204,204,255)"], [0.5, "rgb(255,255,255)"], [0.6, "rgb(255,204,255)"], [0.7, "rgb(255,153,255)"], [0.8, "rgb(255,102,204)"], [0.9, "rgb(255,102,102)"], [1, "rgb(255,0,0)"]], 
  "name": "trace 0", 
  "type": "heatmap", 
  "uid": "8c4bf2", 
  "zmax": 1, 
  "zmin": -0.259871534305
}
data = Data([trace1])
layout = {
  "autosize": False, 
  "height": 440, 
  "margin": {
    "r": 200, 
    "t": 60, 
    "b": 60, 
    "l": 70, 
    "pad": 2
  }, 
  "showlegend": False, 
  "title": "Correlation Matrix", 
  "width": 600, 
  "xaxis": {
    "autorange": True, 
    "linecolor": "rgb(207, 226, 243)", 
    "linewidth": 8, 
    "mirror": True, 
    "nticks": 13, 
    "range": [-0.5, 19.5], 
    "showline": True, 
    "title": "", 
    "type": "linear"
  }, 
  "yaxis": {
    "autorange": True, 
    "linecolor": "rgb(207, 226, 243)", 
    "linewidth": 8, 
    "mirror": True, 
    "nticks": 13, 
    "range": [-0.5, 19.5], 
    "showline": True, 
    "title": "", 
    "type": "linear"
  }
}
fig = Figure(data=data, layout=layout)
if(show == 1):
    plot(fig)

# Test de représentation des données n°5

z_data = data_plant
data = [
    Surface(
        z=z_data.as_matrix()
    )
]
layout = Layout(
    title='',
    autosize=False,
    width=500,
    height=500,
    margin=dict(
        l=65,
        r=50,
        b=65,
        t=90
    )
)
fig = Figure(data=data, layout=layout)
if(show == 1):
    plot(fig, filename='elevations-3d-surface.html')


# Test de représentation des données n°6

x = data_plant[1]
y = data_plant[2]
z = data_plant[3]
trace1 = Scatter3d(
    x = x,
    y = y,
    z = z,
    mode='markers',
    marker=dict(
        size=12,
        line=dict(
            color='rgba(217, 217, 217, 0.14)',
            width=0.5
        ),
        opacity=0.8
    )
)
data = [trace1]
layout = Layout(
    margin=dict(
        l=0,
        r=0,
        b=0,
        t=0
    )
)
fig = Figure(data=data, layout=layout)
if(show == 1):
    plot(fig, filename='simple-3d-scatter.html')


# Test de représentation des données n°7

i = 0
data_size = []
while i < len(data_plant[4]):
    if data_plant[4][i] == "bad":
        data_size.append(0.02)
        i += 1
    else:
        data_size.append(0.2)
        i += 1
trace1 = {
  "x": data_plant[1], 
  "y": data_plant[2], 
  "z": data_plant[3], 
  "marker": {
    "size":  data_size, 
    "sizemode": "area", 
    "sizeref": 0.000194444444444
  }, 
  "mode": "markers", 
  "type": "scatter3d", 
  "uid": "45dcc2"
}
data = Data([trace1])
layout = {
  "autosize": True, 
  "barmode": "group", 
  "dragmode": "turntable", 
  "height": 809, 
  "legend": {
    "x": 0.656849315068, 
    "y": 0.988871224165
  }, 
  "scene": {
    "aspectratio": {
      "x": 1, 
      "y": 1, 
      "z": 1
    }, 
    "camera": {
      "center": {
        "x": 0, 
        "y": 0, 
        "z": 0
      }, 
      "eye": {
        "x": 1.34137546445, 
        "y": 1.25959121454, 
        "z": 0.592485779516
      }, 
      "up": {
        "x": 0, 
        "y": 0, 
        "z": 1
      }
    }, 
    "xaxis": {
      "title": "Hygrometrie", 
      "type": "linear"
    }, 
    "yaxis": {
      "title": "Humidité", 
      "type": "linear"
    }, 
    "zaxis": {
      "title": "Température", 
      "type": "linear"
    }
  }, 
  "showlegend": False, 
  "title": "Représentation data_plant dans un graph 4D", 
  "width": 1620, 
  "xaxis": {"type": "linear"}, 
  "yaxis": {"type": "linear"}
}
fig = Figure(data=data, layout=layout)
if(show == 1):
    plot(fig)


# Utilisation de scikitlearn une bibliothèque orienté Machine Learning

# Etape de préparation
# Division du set de data en :

          # données d'apprentissage
i = 0
target = [[]]
while i < len(data_plant[4]):
    if data_plant[4][i] == "bad":
        target[0].append(0)
        i += 1
    else:
        target[0].append(1)
        i += 1
target = np.reshape(target, (-1, 1))

          # données cibles    
data = data_plant.drop(4, axis=1)

# Import de scikitlearn

from sklearn import neighbors
from sklearn.model_selection import train_test_split

# Division du set de data en données d'entrainement et en données de test

xtrain, xtest, ytrain, ytest = train_test_split(data, target, train_size=0.8)


# Utilisation de l'algorithme des plus proches voisin pour déterminer notre classe

knn = neighbors.KNeighborsClassifier(n_neighbors=12)
knn.fit(xtrain, ytrain.ravel())


# Affichage et prediction du jeu de valeur d'entrainement

knn.predict(xtrain)


# Affichage du jeu de valeur réel

ytrain.ravel()


# Etape de prédiction
# Ouverture du fichier à tester

file = open("predict.txt", "r+") 
m = file.readline()
n = file.readline()
o = file.readline()
p = file.readline()

# Prediction d'un exemple de jeu de valeur

print(knn.predict([[m,n,o,p]]))


# Calcul du pourcentage d'erreur pour un classifieur donnée

1 - knn.score(xtest, ytest)


# Calcul du meilleurs résultat pour un nombre de voisin allant de 2 à 20

krange = range(2,20)
errors = []
for k in krange:
    knn = neighbors.KNeighborsClassifier(k)
    knn.fit(xtrain, ytrain)
    errors.append(1 - knn.score(xtest, ytest))

knn = neighbors.KNeighborsClassifier(n_neighbors=12)
knn.fit(xtrain, ytrain.ravel())


# Affichage du graphique représentant les meilleurs classifieur

if(show == 1):
    plt.plot(krange, errors)
    plt.show()
